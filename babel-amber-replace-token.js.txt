const userVariables = [
  "searchFeedbackButton",
  "topChevronButton",
  "filterButton",
];

export default function ({ types: t }) {
  return {
    visitor: {
      ExportDefaultDeclaration(path) {
        t.assertTSAsExpression(path.node.declaration);
        t.assertObjectExpression(path.node.declaration.expression);

        const slots = path
          .get("declaration")
          .get("expression")
          .get("properties");

        slots.forEach((slot) => {
          const variableProperties = slot.get("value").get("properties");
          variableProperties.forEach((variableProperty) => {
            const currVariable = variableProperty.node.key.name;

            if (userVariables.includes(currVariable)) {
              const styleFunction = variableProperty.get("value");

              replaceTokenWithFullPath({ styleFunction, t });
            }
          });
        });
      },
    },
  };
}

// replace tokens like `foregroundActive` into `colorSchemeBrand.foregroundActive`
const replaceTokenWithFullPath = ({ styleFunction, t }) => {
  const styleFunctionParam = styleFunction.get("params")[0];

  const bindings = styleFunction.scope.bindings;

  for (const bindingValue of Object.values(bindings)) {
    const bindingIdentifier = bindingValue.identifier;
    let variableName = `${bindingIdentifier.name}`;

    // find
    styleFunctionParam.traverse({
      Identifier(path) {
        if (path.node === bindingIdentifier) {
          let parentPath = path.parentPath.parentPath;
          while (parentPath !== styleFunction) {
            if (t.isObjectProperty(parentPath)) {
              variableName = `${parentPath.node.key.name}.${variableName}`;
            }
            parentPath = parentPath.parentPath;
          }
        }
      },
    });

    // replace all usage of this token
    if (variableName !== `${bindingIdentifier.name}`) {
      // TODO here we replace variableName with v9 token name
      const referencePaths = bindingValue.referencePaths;
      referencePaths.forEach((referencePath) => {
        referencePath.replaceWithSourceString(variableName);
      });
    }
  }
};
